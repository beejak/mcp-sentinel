//! Vulnerability data model

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Severity level of a vulnerability
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Severity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

impl Severity {
    /// Convert severity to emoji badge
    pub fn to_emoji(&self) -> &'static str {
        match self {
            Severity::Info => "â„¹ï¸",
            Severity::Low => "ðŸ”µ",
            Severity::Medium => "ðŸŸ¡",
            Severity::High => "ðŸŸ ",
            Severity::Critical => "ðŸ”´",
        }
    }

    /// Convert severity to text badge
    pub fn to_badge(&self) -> &'static str {
        match self {
            Severity::Info => "INFO",
            Severity::Low => "LOW",
            Severity::Medium => "MEDIUM",
            Severity::High => "HIGH",
            Severity::Critical => "CRITICAL",
        }
    }
}

/// Type of vulnerability detected
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum VulnerabilityType {
    ToolPoisoning,
    PromptInjection,
    SensitiveFileAccess,
    DataExfiltration,
    ToxicFlow,
    RugPull,
    ShadowTool,
    CommandInjection,
    PathTraversal,
    SqlInjection,
    UnsafeDeserialization,
    HardcodedCredentials,
    SecretsLeakage,
    PiiExposure,
    CrossOriginEscalation,
    BehavioralAnomaly,
    SupplyChainAttack,
    XssVulnerability,
    PrototypePollution,
    InsecureConfiguration,
    CodeInjection,
    HardcodedSecret,
}

impl VulnerabilityType {
    /// Get human-readable name
    pub fn name(&self) -> &'static str {
        match self {
            VulnerabilityType::ToolPoisoning => "Tool Poisoning Attack",
            VulnerabilityType::PromptInjection => "Prompt Injection",
            VulnerabilityType::SensitiveFileAccess => "Sensitive File Access",
            VulnerabilityType::DataExfiltration => "Data Exfiltration",
            VulnerabilityType::ToxicFlow => "Toxic Flow",
            VulnerabilityType::RugPull => "MCP Rug Pull",
            VulnerabilityType::ShadowTool => "Shadow Tool",
            VulnerabilityType::CommandInjection => "Command Injection",
            VulnerabilityType::PathTraversal => "Path Traversal",
            VulnerabilityType::SqlInjection => "SQL Injection",
            VulnerabilityType::UnsafeDeserialization => "Unsafe Deserialization",
            VulnerabilityType::HardcodedCredentials => "Hardcoded Credentials",
            VulnerabilityType::SecretsLeakage => "Secrets Leakage",
            VulnerabilityType::PiiExposure => "PII Exposure",
            VulnerabilityType::CrossOriginEscalation => "Cross-Origin Escalation",
            VulnerabilityType::BehavioralAnomaly => "Behavioral Anomaly",
            VulnerabilityType::SupplyChainAttack => "Supply Chain Attack",
            VulnerabilityType::XssVulnerability => "Cross-Site Scripting (XSS)",
            VulnerabilityType::PrototypePollution => "Prototype Pollution",
            VulnerabilityType::InsecureConfiguration => "Insecure Configuration",
            VulnerabilityType::CodeInjection => "Code Injection",
            VulnerabilityType::HardcodedSecret => "Hardcoded Secret",
        }
    }
}

/// Location of a vulnerability in source code
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Location {
    pub file: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub line: Option<usize>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub column: Option<usize>,
}

impl Location {
    pub fn new(file: impl Into<String>) -> Self {
        Self {
            file: file.into(),
            line: None,
            column: None,
        }
    }

    pub fn with_line(mut self, line: usize) -> Self {
        self.line = Some(line);
        self
    }

    pub fn with_column(mut self, column: usize) -> Self {
        self.column = Some(column);
        self
    }

    /// Format location as "file:line:column"
    pub fn format(&self) -> String {
        match (self.line, self.column) {
            (Some(line), Some(column)) => format!("{}:{}:{}", self.file, line, column),
            (Some(line), None) => format!("{}:{}", self.file, line),
            _ => self.file.clone(),
        }
    }
}

/// AI analysis result for a vulnerability
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AiAnalysis {
    pub model: String,
    pub explanation: String,
    pub confidence: f32,
}

/// A detected vulnerability
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Vulnerability {
    /// Unique identifier (e.g., "C-001")
    pub id: String,

    /// Type of vulnerability
    #[serde(rename = "type")]
    pub vuln_type: VulnerabilityType,

    /// Severity level
    pub severity: Severity,

    /// Confidence score (0.0 to 1.0)
    pub confidence: f32,

    /// Location in source code
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location: Option<Location>,

    /// Short title
    pub title: String,

    /// Detailed description
    pub description: String,

    /// Impact of the vulnerability
    #[serde(skip_serializing_if = "Option::is_none")]
    pub impact: Option<String>,

    /// Remediation steps
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remediation: Option<String>,

    /// Code snippet showing the vulnerability
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code_snippet: Option<String>,

    /// Example fix
    #[serde(skip_serializing_if = "Option::is_none")]
    pub example_fix: Option<String>,

    /// Additional evidence/context
    #[serde(skip_serializing_if = "Option::is_none")]
    pub evidence: Option<HashMap<String, serde_json::Value>>,

    /// AI analysis (if available)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ai_analysis: Option<AiAnalysis>,

    /// CWE identifier (Common Weakness Enumeration)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cwe_id: Option<usize>,

    /// OWASP category
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owasp: Option<String>,

    /// References/links for more information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub references: Vec<String>,
}

impl Vulnerability {
    /// Create a new vulnerability with minimal required fields
    pub fn new(
        id: impl Into<String>,
        vuln_type: VulnerabilityType,
        severity: Severity,
        title: impl Into<String>,
        description: impl Into<String>,
    ) -> Self {
        Self {
            id: id.into(),
            vuln_type,
            severity,
            confidence: 1.0,
            location: None,
            title: title.into(),
            description: description.into(),
            impact: None,
            remediation: None,
            code_snippet: None,
            example_fix: None,
            evidence: None,
            ai_analysis: None,
            cwe_id: None,
            owasp: None,
            references: vec![],
        }
    }

    /// Builder method to set location
    pub fn with_location(mut self, location: Location) -> Self {
        self.location = Some(location);
        self
    }

    /// Builder method to set impact
    pub fn with_impact(mut self, impact: impl Into<String>) -> Self {
        self.impact = Some(impact.into());
        self
    }

    /// Builder method to set remediation
    pub fn with_remediation(mut self, remediation: impl Into<String>) -> Self {
        self.remediation = Some(remediation.into());
        self
    }

    /// Builder method to set confidence
    pub fn with_confidence(mut self, confidence: f32) -> Self {
        self.confidence = confidence.clamp(0.0, 1.0);
        self
    }

    /// Builder method to set code snippet
    pub fn with_code_snippet(mut self, snippet: impl Into<String>) -> Self {
        self.code_snippet = Some(snippet.into());
        self
    }

    /// Builder method to set evidence
    pub fn with_evidence(mut self, evidence: HashMap<String, serde_json::Value>) -> Self {
        self.evidence = Some(evidence);
        self
    }

    /// Builder method to set AI analysis
    pub fn with_ai_analysis(mut self, analysis: AiAnalysis) -> Self {
        self.ai_analysis = Some(analysis);
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_severity_ordering() {
        assert!(Severity::Critical > Severity::High);
        assert!(Severity::High > Severity::Medium);
        assert!(Severity::Medium > Severity::Low);
    }

    #[test]
    fn test_location_format() {
        let loc = Location::new("test.py").with_line(42).with_column(10);
        assert_eq!(loc.format(), "test.py:42:10");

        let loc = Location::new("test.py").with_line(42);
        assert_eq!(loc.format(), "test.py:42");

        let loc = Location::new("test.py");
        assert_eq!(loc.format(), "test.py");
    }

    #[test]
    fn test_vulnerability_builder() {
        let vuln = Vulnerability::new(
            "C-001",
            VulnerabilityType::CommandInjection,
            Severity::Critical,
            "Command Injection",
            "Unsafe command execution",
        )
        .with_location(Location::new("test.py").with_line(10))
        .with_impact("Remote code execution")
        .with_confidence(0.95);

        assert_eq!(vuln.id, "C-001");
        assert_eq!(vuln.severity, Severity::Critical);
        assert_eq!(vuln.confidence, 0.95);
        assert!(vuln.location.is_some());
        assert!(vuln.impact.is_some());
    }
}
